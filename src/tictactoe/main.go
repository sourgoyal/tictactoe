package main

import (
	"errors"
	"log"
	"net/url"
	"os"
	"strings"

	"tictactoe/gamesDB"
	"tictactoe/gen/models"
	"tictactoe/gen/restapi"
	"tictactoe/gen/restapi/operations"

	loads "github.com/go-openapi/loads"
	"github.com/go-openapi/runtime/middleware"
	"github.com/go-openapi/strfmt"
	"github.com/google/uuid"
	flags "github.com/jessevdk/go-flags"
)

// This file was generated by the swagger tool.
// Make sure not to overwrite this file after you generated it because all your edits would be lost!

func main() {

	swaggerSpec, err := loads.Embedded(restapi.SwaggerJSON, restapi.FlatSwaggerJSON)
	if err != nil {
		log.Fatalln(err)
	}

	api := operations.NewTictactoeAPI(swaggerSpec)
	server := restapi.NewServer(api)
	defer server.Shutdown()

	parser := flags.NewParser(server, flags.Default)
	parser.ShortDescription = "Tic-tac-toe"
	parser.LongDescription = swaggerSpec.Spec().Info.Description

	server.ConfigureFlags()
	for _, optsGroup := range api.CommandLineOptionsGroups {
		_, err := parser.AddGroup(optsGroup.ShortDescription, optsGroup.LongDescription, optsGroup.Options)
		if err != nil {
			log.Fatalln(err)
		}
	}

	if _, err := parser.Parse(); err != nil {
		code := 1
		if fe, ok := err.(*flags.Error); ok {
			if fe.Type == flags.ErrHelp {
				code = 0
			}
		}
		os.Exit(code)
	}

	games := gamesDB.NewGameDB()
	go games.Cleanup()

	api.GetAPIV1GamesHandler = operations.GetAPIV1GamesHandlerFunc(func(params operations.GetAPIV1GamesParams) middleware.Responder {

		allGamesPayload, _ := getAllGames(games)
		return operations.NewGetAPIV1GamesOK().WithPayload(allGamesPayload)
	})
	api.GetAPIV1GamesGameIDHandler = operations.GetAPIV1GamesGameIDHandlerFunc(func(params operations.GetAPIV1GamesGameIDParams) middleware.Responder {
		return getGameDetails(games, params.GameID)
	})

	api.DeleteAPIV1GamesGameIDHandler = operations.DeleteAPIV1GamesGameIDHandlerFunc(func(params operations.DeleteAPIV1GamesGameIDParams) middleware.Responder {
		return deleteGame(games, params.GameID)
	})

	api.PostAPIV1GamesHandler = operations.PostAPIV1GamesHandlerFunc(func(params operations.PostAPIV1GamesParams) middleware.Responder {
		// if err := createGame(games, params.Game); err != nil {
		// 	log.Print("Cant' create a game")
		// }
		return createGame(games, params.Game, params.HTTPRequest.URL)
		// return operations.NewPostAPIV1GamesCreated()
	})
	api.PutAPIV1GamesGameIDHandler = operations.PutAPIV1GamesGameIDHandlerFunc(func(params operations.PutAPIV1GamesGameIDParams) middleware.Responder {
		return userBackendPlayHandler(games, params.GameID, params.Game)
	})

	server.ConfigureAPI()

	if err := server.Serve(); err != nil {
		log.Fatalln(err)
	}
}

// /api/v1/games/{game_id}:
// put:
//       description: Post a new move to a game.
//       parameters:
//         -
//           name: game_id
//           in: path
//           description: Game id
//           required: true
//           type: string
//           format: uuid
//         -
//           name: game
//           in: body
//           required: true
//           schema:
//             $ref: "#/definitions/game"

//       responses:
//         200:
//           description: Move successfully registered, also provide backend's response move in response
//           schema:
//               $ref: "#/definitions/game"
//         400:
//           description: Bad request
//           schema:
//             type: object
//             properties:
//               reason:
//                 type: string
//                 description: Why the game failed to update
//         404:
//           description: Resource not found
//         500:
//           description: Internal server error
func userBackendPlayHandler(games *gamesDB.GamesDB, gameID strfmt.UUID, game *models.Game) middleware.Responder {
	existGame, errCode := games.GetGameData(gameID)

	if errCode != gamesDB.Success {
		badReq := operations.NewPutAPIV1GamesGameIDBadRequest()
		badReq.SetPayload(&operations.PutAPIV1GamesGameIDBadRequestBody{Reason: "This game doesn't exist"})
		return badReq
	}

	if !existGame.UserTurn {
		badReq := operations.NewPutAPIV1GamesGameIDBadRequest()
		badReq.SetPayload(&operations.PutAPIV1GamesGameIDBadRequestBody{Reason: "Please wait for your turn"})
		return badReq
	}

	userSym, err := validateUserMove(*game.Board, *existGame.Game.Board)
	if err != nil {
		badReq := operations.NewPutAPIV1GamesGameIDBadRequest()
		badReq.SetPayload(&operations.PutAPIV1GamesGameIDBadRequestBody{Reason: err.Error()})
		return badReq
	}

	if userSym != existGame.UserSymbol {
		badReq := operations.NewPutAPIV1GamesGameIDBadRequest()
		badReq.SetPayload(&operations.PutAPIV1GamesGameIDBadRequestBody{Reason: "Invalid Symbol used"})
		return badReq
	}

	gameStatus := getGameStatus(*game.Board)
	backendGame := models.Game{ID: gameID}
	backendGame.Board = game.Board
	if gameStatus == models.GameStatusRUNNING {
		bkSym := getBkSym(userSym)
		bkBoard := backendMove([]rune(*game.Board), bkSym)
		backendGame.Board = &bkBoard
		gameStatus = getGameStatus(bkBoard)
	}

	backendGame.Status = gameStatus
	gameD := gamesDB.GameData{UserSymbol: userSym, UserTurn: true, Game: backendGame}
	if gameStatus == models.GameStatusRUNNING {
		if errCode := games.UpdateGame(gameD, gameID); errCode != gamesDB.Success {
			return operations.NewPutAPIV1GamesGameIDInternalServerError()
		}
	} else {
		if errCode := games.DeleteGame(gameID); errCode != gamesDB.Success {
			log.Printf("Failed to delete after Game over. Background cleanup must clean this game %+v", gameID)
		}
	}
	log.Printf("PUT GameID %+v Received Board %s, userSym %#U, CSBoard %s", gameID, *game.Board, userSym, *backendGame.Board)
	return operations.NewPutAPIV1GamesGameIDOK().WithPayload(&backendGame)
}

func winner(sym rune) string {
	if sym == 'X' {
		return models.GameStatusXWON
	}
	return models.GameStatusOWON
}

func getGameStatus(board string) string {
	b := []rune(board)

	// Diagonal
	if b[0] != '-' && b[0] == b[4] && b[0] == b[8] {
		return winner(b[0])
	}
	if b[2] != '-' && b[2] == b[4] && b[2] == b[6] {
		return winner(b[2])
	}

	// Rows
	if b[0] != '-' && b[0] == b[1] && b[1] == b[2] {
		return winner(b[0])
	}
	if b[3] != '-' && b[3] == b[4] && b[3] == b[5] {
		return winner(b[3])
	}
	if b[6] != '-' && b[6] == b[7] && b[7] == b[8] {
		return winner(b[6])
	}

	// Collumns
	if b[0] != '-' && b[0] == b[3] && b[3] == b[6] {
		return winner(b[0])
	}
	if b[1] != '-' && b[1] == b[4] && b[1] == b[7] {
		return winner(b[1])
	}
	if b[2] != '-' && b[2] == b[5] && b[2] == b[8] {
		return winner(b[2])
	}

	for i := range board {
		if board[i] == '-' {
			return models.GameStatusRUNNING
		}
	}
	return models.GameStatusDRAW
}

// /api/v1/games:
// post:
//       description: Start a new game.
//       parameters:
//         -
//           name: game
//           in: body
//           required: true
//           schema:
//             $ref: "#/definitions/game"

//       responses:
//         201:
//           description: Game successfully started
//           headers:
//               Location:
//                 type: string
//                 description: URL of the started game
//           schema:
//             type: object
//             properties:
//               location:
//                 type: string
//                 description: URL of the started game
//         400:
//           description: Bad request
//           schema:
//             type: object
//             properties:
//               reason:
//                 type: string
//                 description: Why the game failed to start
//         404:
//           description: Resource not found
//         500:
//           description: Internal server error
func createGame(games *gamesDB.GamesDB, game *models.Game, reqURL *url.URL) middleware.Responder {
	id, err := uuid.NewUUID()
	if err != nil {
		return operations.NewPostAPIV1GamesInternalServerError()
	}
	gameID := strfmt.UUID(id.String())

	if games.GameExists(gameID) {
		return operations.NewPostAPIV1GamesInternalServerError()
	}

	board := game.Board

	userSym, err := validateUserMove(*board, Blank)
	if err != nil {
		return operations.NewPostAPIV1GamesBadRequest()
	}

	bkSym := getBkSym(userSym)
	bkBoard := backendMove([]rune(*board), bkSym)

	backendGame := models.Game{Board: &bkBoard, ID: gameID, Status: models.GameStatusRUNNING}
	gameD := gamesDB.GameData{UserSymbol: userSym, UserTurn: true, Game: backendGame}
	if errCode := games.AddGame(gameD, gameID); errCode != gamesDB.Success {
		return operations.NewPostAPIV1GamesInternalServerError()
	}

	log.Printf("Created a new gameID %+v", gameID)
	log.Printf("Received Board %s, userSym %#U, URL %s", *board, userSym, reqURL.String())
	respURL := reqURL
	respURL.Path = respURL.Path + "/" + string(gameID)
	respPost := operations.NewPostAPIV1GamesCreated()
	respPost.SetLocation(reqURL.String())
	respPost.SetPayload(&operations.PostAPIV1GamesCreatedBody{Location: respURL.String()})
	return respPost
}

func getBkSym(userSym rune) rune {
	if userSym == 'X' {
		return 'O'
	}
	return 'X'
}

func backendMove(currBoard []rune, bkSym rune) string {
	bkBoard := make([]rune, 9)
	copy(bkBoard, currBoard)

	for i := range currBoard {
		if currBoard[i] == '-' {
			bkBoard[i] = bkSym
			return string(bkBoard)
		} else {
			bkBoard[i] = currBoard[i]
		}
	}

	return string(bkBoard)
}

func validateUserMove(board string, before string) (rune, error) {
	userSym := rune('X')
	if len(board) != 9 {
		return userSym, errors.New("Invalid Input! board length is not 9")
	}

	moves := 0
	for i := range board {
		if board[i] != before[i] {
			moves++
			if moves > 1 || before[i] != '-' {
				return userSym, errors.New("Invalid Input! You Can't play more than one move at once")
			}
			userSym = rune(board[i])
		}
	}

	if before == Blank {
		if board == Blank {
			return 'X', nil
		}
		if strings.ContainsRune(board, 'O') {
			return 'O', nil
		}
	} else {
		if moves == 0 {
			return userSym, errors.New("Please make your move")
		}
	}

	return userSym, nil
}

// /api/v1/games/{game_id}:
// delete:
//       description: Delete a game.
//       parameters:
//         -
//           name: game_id
//           in: path
//           description: Game id
//           required: true
//           type: string
//           format: uuid

//       responses:
//         200:
//           description: Game successfully deleted
//         400:
//           description: Bad request
//         404:
//           description: Resource not found
//         500:
//           description: Internal server error
func deleteGame(games *gamesDB.GamesDB, ID strfmt.UUID) middleware.Responder {
	if errCode := games.DeleteGame(ID); errCode != gamesDB.Success {
		return operations.NewDeleteAPIV1GamesGameIDNotFound()
	}

	return operations.NewDeleteAPIV1GamesGameIDOK()
}

// /api/v1/games/{game_id}:
//     get:
//       description: Get a game.
//       parameters:
//         -
//           name: game_id
//           in: path
//           description: Game id
//           required: true
//           type: string
//           format: uuid

//       responses:
//         200:
//           description: Successful response, returns the game
//           schema:
//               $ref: "#/definitions/game"
//         400:
//           description: Bad request
//         404:
//           description: Resource not found
//         500:
//           description: Internal server error
func getGameDetails(games *gamesDB.GamesDB, ID strfmt.UUID) middleware.Responder {
	var errCode gamesDB.GameDBErrorCode
	var game models.Game
	if game, errCode = games.GetGame(ID); errCode != gamesDB.Success {
		return operations.NewGetAPIV1GamesGameIDNotFound()
	}

	return operations.NewGetAPIV1GamesGameIDOK().WithPayload(&game)
}

//paths:
// /api/v1/games:
// get:
//   description: Get all games.
//   responses:
// 	200:
// 	  description: Successful response, returns an array of games, returns an empty array if no users found
// 	  schema:
// 		type: array
// 		items:
// 		  $ref: "#/definitions/game"
// 	400:
// 	  description: Bad request
// 	404:
// 	  description: Resource not found
// 	500:
// 	  description: Internal server error
func getAllGames(games *gamesDB.GamesDB) ([]*models.Game, error) {
	payload := make([]*models.Game, games.Total())
	// board := "---------"
	// pay := models.Game{Board: &board, Status: "RUNNING", ID: "11"}
	// payload[0] = &pay

	games.Range(func(game gamesDB.GameData) {
		payload = append(payload, &game.Game)
	})

	return payload, nil
}

const (
	Noughts string = "Noughts"
	Crosses string = "Crosses"
	Blank   string = "---------"
)
